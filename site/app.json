[{"name":"app.R","content":"library(shiny)\n\n# Define UI for app that draws a histogram ----\nui <- fluidPage(\n\n  # App title ----\n  titlePanel(\"Hello Shiny!\"),\n\n  # Sidebar layout with input and output definitions ----\n  sidebarLayout(\n\n    # Sidebar panel for inputs ----\n    sidebarPanel(\n\n      # Input: Slider for the number of bins ----\n      sliderInput(\n        inputId = \"bins\",\n        label = \"Number of bins:\",\n        min = 2,\n        max = 50,\n        value = 30\n      )\n    ),\n\n    # Main panel for displaying outputs ----\n    mainPanel(\n\n      # Output: Histogram ----\n      plotOutput(outputId = \"distPlot\")\n    )\n  )\n)\n\n# Define server logic required to draw a histogram ----\nserver <- function(input, output) {\n  # Histogram of the Old Faithful Geyser Data ----\n  # with requested number of bins\n  # This expression that generates a histogram is wrapped in a call\n  # to renderPlot to indicate that:\n  #\n  # 1. It is \"reactive\" and therefore should be automatically\n  #    re-executed when inputs (input$bins) change\n  # 2. Its output type is a plot\n  output$distPlot <- renderPlot({\n    x <- faithful$waiting\n    bins <- seq(min(x), max(x), length.out = input$bins + 1)\n\n    hist(x,\n      breaks = bins, col = \"#75AADB\", border = \"white\",\n      xlab = \"Waiting time to next eruption (in mins)\",\n      main = \"Histogram of waiting times\"\n    )\n  })\n}\n\n# Create Shiny app ----\nshinyApp(ui = ui, server = server)\n","type":"text"},{"name":"DESCRIPTION","content":"Title: Hello Shiny!\nAuthor: RStudio, Inc.\nAuthorUrl: http://www.rstudio.com/\nLicense: MIT\nDisplayMode: Showcase\nTags: getting-started\nType: Shiny\n","type":"text"},{"name":"Readme.md","content":"This small Shiny application demonstrates Shiny's automatic UI updates. \n\nMove the *Number of bins* slider and notice how the `renderPlot` expression is automatically re-evaluated when its dependant, `input$bins`, changes, causing a histogram with a new number of bins to be rendered.\n","type":"text"},{"name":"_extensions/quarto-ext/shinylive/README.md","content":"# Shinylive package methods\n\n## Methods\n\n### R\n\nInteraction:\n\n```\nRscript -e 'shinylive:::quarto_ext()' [methods] [args]\n```\n\n### Python\n\nInteraction:\n\n```\nshinylive [methods] [args]\n```\n\n## CLI Methods\n\n* `extension info`\n  * Package, version, asset version, and script paths information\n* `extension base-htmldeps`\n  * Quarto html dependencies for the base shinylive integration\n* `extension language-resources`\n  * Language specific resource files for the quarto html dependency named `shinylive`\n* `extension app-resources`\n  * App specific resource files for the quarto html dependency named `shinylive`\n\n### CLI Interface\n* `extension info`\n  * Prints information about the extension including:\n    * `version`: The version of the R package\n    * `assets_version`: The version of the web assets\n    * `scripts`: A list of paths scripts that are used by the extension,\n     mainly `codeblock-to-json`\n  * Example\n    ```\n    {\n      \"version\": \"0.1.0\",\n      \"assets_version\": \"0.2.0\",\n      \"scripts\": {\n        \"codeblock-to-json\": \"/<ASSETS_CACHE_DIR>/shinylive-0.2.0/scripts/codeblock-to-json.js\"\n      }\n    }\n    ```\n* `extension base-htmldeps`\n  * Prints the language agnostic quarto html dependencies as a JSON array.\n    * The first html dependency is the `shinylive` service workers.\n    * The second html dependency is the `shinylive` base dependencies. This\n      dependency will contain the core `shinylive` asset scripts (JS files\n      automatically sourced), stylesheets (CSS files that are automatically\n      included), and resources (additional files that the JS and CSS files can\n      source).\n  * Example\n    ```\n    [\n      {\n        \"name\": \"shinylive-serviceworker\",\n        \"version\": \"0.2.0\",\n        \"meta\": { \"shinylive:serviceworker_dir\": \".\" },\n        \"serviceworkers\": [\n          {\n            \"source\": \"/<ASSETS_CACHE_DIR>/shinylive-0.2.0/shinylive-sw.js\",\n            \"destination\": \"/shinylive-sw.js\"\n          }\n        ]\n      },\n      {\n        \"name\": \"shinylive\",\n        \"version\": \"0.2.0\",\n        \"scripts\": [{\n          \"name\": \"shinylive/load-shinylive-sw.js\",\n          \"path\": \"/<ASSETS_CACHE_DIR>/shinylive-0.2.0/shinylive/load-shinylive-sw.js\",\n            \"attribs\": { \"type\": \"module\" }\n        }],\n        \"stylesheets\": [{\n          \"name\": \"shinylive/shinylive.css\",\n          \"path\": \"/<ASSETS_CACHE_DIR>/shinylive-0.2.0/shinylive/shinylive.css\"\n        }],\n        \"resources\": [\n          {\n            \"name\": \"shinylive/shinylive.js\",\n            \"path\": \"/<ASSETS_CACHE_DIR>/shinylive-0.2.0/shinylive/shinylive.js\"\n          },\n          ... # [ truncated ]\n        ]\n      }\n    ]\n    ```\n* `extension language-resources`\n  * Prints the language-specific resource files as JSON that should be added to the quarto html dependency.\n    * For r-shinylive, this includes the webr resource files\n    * For py-shinylive, this includes the pyodide and pyright resource files.\n  * Example\n    ```\n    [\n      {\n        \"name\": \"shinylive/webr/esbuild.d.ts\",\n        \"path\": \"/<ASSETS_CACHE_DIR>/shinylive-0.2.0/shinylive/webr/esbuild.d.ts\"\n      },\n      {\n        \"name\": \"shinylive/webr/libRblas.so\",\n        \"path\": \"/<ASSETS_CACHE_DIR>/shinylive-0.2.0/shinylive/webr/libRblas.so\"\n      },\n      ... # [ truncated ]\n    ]\n* `extension app-resources`\n  * Prints app-specific resource files as JSON that should be added to the `\"shinylive\"` quarto html dependency.\n  * Currently, r-shinylive does not return any resource files.\n  * Example\n    ```\n    [\n      {\n        \"name\": \"shinylive/pyodide/anyio-3.7.0-py3-none-any.whl\",\n        \"path\": \"/<ASSETS_CACHE_DIR>/shinylive-0.2.0/shinylive/pyodide/anyio-3.7.0-py3-none-any.whl\"\n      },\n      {\n        \"name\": \"shinylive/pyodide/appdirs-1.4.4-py2.py3-none-any.whl\",\n        \"path\": \"/<ASSETS_CACHE_DIR>/shinylive-0.2.0/shinylive/pyodide/appdirs-1.4.4-py2.py3-none-any.whl\"\n      },\n      ... # [ truncated ]\n    ]\n    ```\n","type":"text"},{"name":"_extensions/quarto-ext/shinylive/_extension.yml","content":"name: shinylive\ntitle: Embedded Shinylive applications\nauthor: Winston Chang\nversion: 0.1.0\nquarto-required: \">=1.2.198\"\ncontributes:\n  filters:\n    - shinylive.lua\n","type":"text"},{"name":"_extensions/quarto-ext/shinylive/resources/css/shinylive-quarto.css","content":"div.output-content,\ndiv.shinylive-wrapper {\n  background-color: rgba(250, 250, 250, 0.65);\n  border: 1px solid rgba(233, 236, 239, 0.65);\n  border-radius: 0.5rem;\n  box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.04), 0px 3px 7px rgba(0, 0, 0, 0.04),\n    0px 12px 30px rgba(0, 0, 0, 0.07);\n  margin-top: 32px;\n  margin-bottom: 32px;\n}\n\ndiv.shinylive-wrapper {\n  margin: 1em 0;\n  border-radius: 8px;\n}\n\n.shinylive-container {\n  background-color: #eeeff2;\n  min-height: auto;\n}\n\n.shinylive-container > div {\n  box-shadow: none;\n}\n\n.editor-container .cm-editor .cm-scroller {\n  font-size: 13px;\n  line-height: 1.5;\n}\n\niframe.app-frame {\n  /* Override the default margin from Bootstrap */\n  margin-bottom: 0;\n}\n","type":"text"},{"name":"_extensions/quarto-ext/shinylive/shinylive.lua","content":"-- Notes:\n-- * 2023/10/04 - Barret:\n--   Always use `callShinyLive()` to call a shinylive extension.\n--   `callPythonShinyLive()` and `callRShinyLive()` should not be used directly.\n--   Instead, always use `callShinyLive()`.\n-- * 2023/10/04 - Barret:\n--   I could not get `error(msg)` to quit the current function execution and\n--   bubble up the stack and stop. Instead, I am using `assert(false, msg)` to\n--   achieve the desired behavior. Multi-line error messages should start with a\n--   `\\n` to keep the message in the same readable area.\n\n\n-- `table` to organize flags to have code only run once.\nlocal hasDoneSetup = { base = false, r = false, python = false, python_version = false }\n-- `table` to store `{ version, assets_version }` for each language's extension.\n-- If both `r` and `python` are used in the same document, then the\n-- `assets_version` for each language must be the same.\nlocal versions = { r = nil, python = nil }\n-- Global variable for the codeblock-to-json.js script file location\nlocal codeblockScript = nil\n-- Global hash table to store app specific dependencies to avoid calling\n-- `quarto.doc.attach_to_dependency()` multiple times for the same dependency.\nlocal appSpecificDeps = {}\n\n-- Display error message and throw error w/ short message\n-- @param msg: string Error message to be displayed\n-- @param short_msg: string Error message to be thrown\nfunction throw_quarto_error(err_msg, ...)\n  n = select(\"#\", ...)\n  if n > 0 then\n    -- Display any meta information about the error\n    -- Add blank lines after msg for line separation for better readability\n    quarto.log.error(...)\n  else\n    quarto.log.error(err_msg .. \"\\n\\n\")\n  end\n  -- Add blank lines after short_msg for line separation for better readability\n  -- Use assert(false, msg) to quit the current function execution and\n  -- bubble up the stack and stop. Barret: I could not get this to work with `error(msg)`.\n  assert(false, err_msg .. \"\\n\")\nend\n\n-- Python specific method to call py-shinylive\n-- @param args: list of string arguments to pass to py-shinylive\n-- @param input: string to pipe into to py-shinylive\nfunction callPythonShinylive(args, input)\n  -- Try calling `pandoc.pipe('shinylive', ...)` and if it fails, print a message\n  -- about installing shinylive python package.\n  local res\n  local status, err = pcall(\n    function()\n      res = pandoc.pipe(\"shinylive\", args, input)\n    end\n  )\n\n  if not status then\n    throw_quarto_error(\n      \"Error running 'shinylive' command. Perhaps you need to install / update the 'shinylive' Python package?\",\n      \"Error running 'shinylive' command. Perhaps you need to install / update the 'shinylive' Python package?\\n\",\n      \"Error:\\n\",\n      err\n    )\n  end\n\n  return res\nend\n\n-- R specific method to call {r-shinylive}\n-- @param args: list of string arguments to pass to r-shinylive\n-- @param input: string to pipe into to r-shinylive\nfunction callRShinylive(args, input)\n  args = { \"-e\",\n    \"shinylive:::quarto_ext()\",\n    table.unpack(args) }\n\n  -- Try calling `pandoc.pipe('Rscript', ...)` and if it fails, print a message\n  -- about installing shinylive R package.\n  local res\n  local status, err = pcall(\n    function()\n      res = pandoc.pipe(\"Rscript\", args, input)\n    end\n  )\n\n  if not status then\n    throw_quarto_error(\n      \"Error running 'Rscript' command. Perhaps you need to install / update the 'shinylive' R package?\",\n      \"Error running 'Rscript' command. Perhaps you need to install / update the 'shinylive' R package?\\n\",\n      \"Error:\\n\",\n      err\n    )\n  end\n\n  return res\nend\n\n-- Returns decoded object\n-- @param language: \"python\" or \"r\"\n-- @param args, input: see `callPythonShinylive` and `callRShinylive`\nfunction callShinylive(language, args, input, parseJson)\n  if input == nil then\n    input = \"\"\n  end\n  if parseJson == nil then\n    parseJson = true\n  end\n\n  local res\n  -- print(\"Calling \" .. language .. \" shinylive with args: \", args)\n  if language == \"python\" then\n    res = callPythonShinylive(args, input)\n  elseif language == \"r\" then\n    res = callRShinylive(args, input)\n  else\n    throw_quarto_error(\"internal - Unknown language: \" .. language)\n  end\n\n  if not parseJson then\n    return res\n  end\n\n  -- Remove any unwanted output before the first curly brace or square bracket.\n  -- print(\"res: \" .. string.sub(res, 1, math.min(string.len(res), 100)) .. \"...\")\n  local curly_start = string.find(res, \"{\", 0, true)\n  local brace_start = string.find(res, \"[\", 0, true)\n  local min_start\n  if curly_start == nil then\n    min_start = brace_start\n  elseif brace_start == nil then\n    min_start = curly_start\n  else\n    min_start = math.min(curly_start, brace_start)\n  end\n  if min_start == nil then\n    local res_str = res\n    if string.len(res) > 100 then\n      res_str = string.sub(res, 1, 100) .. \"... [truncated]\"\n    end\n    throw_quarto_error(\n      \"Could not find start curly brace or start brace in \" ..\n      language .. \" shinylive response. Is JSON being returned from the \" .. language .. \" `shinylive` package?\",\n      \"Could not find start curly brace or start brace in \" .. language .. \" shinylive response.\\n\",\n      \"JSON string being parsed:\\n\",\n      res_str\n    )\n  end\n  if min_start > 1 then\n    res = string.sub(res, min_start)\n  end\n\n\n  -- Decode JSON object\n  local result\n  local status, err = pcall(\n    function()\n      result = quarto.json.decode(res)\n    end\n  )\n  if not status then\n    throw_quarto_error(\n      \"Error decoding JSON response from `shinylive` \" .. language .. \" package.\",\n      \"Error decoding JSON response from `shinylive` \" .. language .. \" package.\\n\",\n      \"JSON string being parsed:\\n\",\n      res,\n      \"Error:\\n\",\n      err\n    )\n  end\n  return result\nend\n\nfunction parseVersion(versionTxt)\n  local versionParts = {}\n  for part in string.gmatch(versionTxt, \"%d+\") do\n    table.insert(versionParts, tonumber(part))\n  end\n  local ret = {\n    major = nil,\n    minor = nil,\n    patch = nil,\n    extra = nil,\n    length = #versionParts,\n    str = versionTxt\n  }\n\n  if ret.length >= 1 then\n    ret.major = versionParts[1]\n    if ret.length >= 2 then\n      ret.minor = versionParts[2]\n      if ret.length >= 3 then\n        ret.patch = versionParts[3]\n        if ret.length >= 4 then\n          ret.extra = versionParts[4]\n        end\n      end\n    end\n  end\n\n  return ret\nend\n\n-- If verA > verB, return 1\n-- If verA == verB, return 0\n-- If verA < verB, return -1\nfunction compareVersions(verA, verB)\n  if verA.major == nil or verB.major == nil then\n    throw_quarto_error(\"Trying to compare an invalid version: \" .. verA.str .. \" or \" .. verB.str)\n  end\n\n  for index, key in ipairs({ \"major\", \"minor\", \"patch\", \"extra\" }) do\n    local partDiff = compareVersionPart(verA[key], verB[key])\n    if partDiff ~= 0 then\n      return partDiff\n    end\n  end\n\n  -- Equal!\n  return 0\nend\n\nfunction compareVersionPart(aPart, bPart)\n  if aPart == nil and bPart == nil then\n    return 0\n  end\n  if aPart == nil then\n    return -1\n  end\n  if bPart == nil then\n    return 1\n  end\n  if aPart > bPart then\n    return 1\n  elseif aPart < bPart then\n    return -1\n  end\n\n  -- Equal!\n  return 0\nend\n\nfunction ensurePyshinyliveVersion(language)\n  -- Quit early if not python\n  if language ~= \"python\" then\n    return\n  end\n  -- Quit early if already completed check\n  if hasDoneSetup.python_version then\n    return\n  end\n  hasDoneSetup.python_version = true\n\n  -- Verify that min python shinylive version is met\n  pyShinyliveVersion = callShinylive(language, { \"--version\" }, \"\", false)\n  -- Remove trailing whitespace\n  pyShinyliveVersion = pyShinyliveVersion:gsub(\"%s+$\", \"\")\n  -- Parse version into table\n  parsedVersion = parseVersion(pyShinyliveVersion)\n\n  -- Verify that the version is at least 0.1.0\n  if\n      (parsedVersion.length < 3) or\n      -- Major and minor values are 0. Ex: 0.0.18\n      (parsedVersion.major == 0 and parsedVersion.minor == 0)\n  then\n    assert(false,\n      \"\\nThe shinylive Python package must be at least version v0.1.0 to be used in a Quarto document.\" ..\n      \"\\n\\nInstalled Python Shinylive package version: \" .. pyShinyliveVersion ..\n      \"\\n\\nPlease upgrade the Python Shinylive package by running:\" ..\n      \"\\n\\tpip install --upgrade shinylive\" ..\n      \"\\n\\n(If you are using a virtual environment, please activate it before running the command above.)\"\n    )\n  end\nend\n\n-- Do one-time setup for language agnostic html dependencies.\n-- This should only be called once per document\n-- @param language: \"python\" or \"r\"\nfunction ensureBaseSetup(language)\n  -- Quit early if already done\n  if hasDoneSetup.base then\n    return\n  end\n  hasDoneSetup.base = true\n\n  -- Find the path to codeblock-to-json.ts and save it for later use.\n  local infoObj = callShinylive(language, { \"extension\", \"info\" })\n  -- Store the path to codeblock-to-json.ts for later use\n  codeblockScript = infoObj.scripts['codeblock-to-json']\n  -- Store the version info for later use\n  versions[language] = { version = infoObj.version, assets_version = infoObj.assets_version }\n\n  -- Add language-agnostic dependencies\n  local baseDeps = getShinyliveBaseDeps(language)\n  for idx, dep in ipairs(baseDeps) do\n    quarto.doc.add_html_dependency(dep)\n  end\n\n  -- Add ext css dependency\n  quarto.doc.add_html_dependency(\n    {\n      name = \"shinylive-quarto-css\",\n      stylesheets = { \"resources/css/shinylive-quarto.css\" }\n    }\n  )\nend\n\n-- Do one-time setup for language specific html dependencies.\n-- This should only be called once per document\n-- @param language: \"python\" or \"r\"\nfunction ensureLanguageSetup(language)\n  -- Min version check must be done first\n  ensurePyshinyliveVersion(language)\n\n  -- Make sure the base setup is done before the langage setup\n  ensureBaseSetup(language)\n\n  if hasDoneSetup[language] then\n    return\n  end\n  hasDoneSetup[language] = true\n\n  -- Only get the asset version value if it hasn't been retrieved yet.\n  if versions[language] == nil then\n    local infoObj = callShinylive(language, { \"extension\", \"info\" })\n    versions[language] = { version = infoObj.version, assets_version = infoObj.assets_version }\n  end\n  -- Verify that the r-shinylive and py-shinylive supported assets versions match\n  if\n      (versions.r and versions.python) and\n      ---@diagnostic disable-next-line: undefined-field\n      versions.r.assets_version ~= versions.python.assets_version\n  then\n    local parsedRAssetsVersion = parseVersion(versions.r.assets_version)\n    local parsedPythonAssetsVersion = parseVersion(versions.python.assets_version)\n\n    local verDiff = compareVersions(parsedRAssetsVersion, parsedPythonAssetsVersion)\n    local verDiffStr = \"\"\n    if verDiff == 1 then\n      -- R shinylive supports higher version of assets. Upgrade python shinylive\n      verDiffStr =\n          \"The currently installed python shinylive package supports a lower assets version, \" ..\n          \"therefore we recommend updating your python shinylive package to the latest version.\"\n    elseif verDiff == -1 then\n      -- Python shinylive supports higher version of assets. Upgrade R shinylive\n      verDiffStr =\n          \"The currently installed R shinylive package supports a lower assets version, \" ..\n          \"therefore we recommend updating your R shinylive package to the latest version.\"\n    end\n\n    throw_quarto_error(\n      \"The shinylive R and Python packages must support the same Shinylive Assets version to be used in the same Quarto document.\",\n      \"The shinylive R and Python packages must support the same Shinylive Assets version to be used in the same Quarto document.\\n\",\n      \"\\n\",\n      \"Python shinylive package version: \",\n      ---@diagnostic disable-next-line: undefined-field\n      versions.python.version .. \" ; Supported assets version: \" .. versions.python.assets_version .. \"\\n\",\n      \"R shinylive package version:       \" ..\n      ---@diagnostic disable-next-line: undefined-field\n      versions.r.version .. \" ; Supported assets version: \" .. versions.r.assets_version .. \"\\n\",\n      \"\\n\",\n      verDiffStr .. \"\\n\",\n      \"\\n\",\n      \"To update your R Shinylive package, run:\\n\",\n      \"\\tR -e \\\"install.packages('shinylive')\\\"\\n\",\n      \"\\n\",\n      \"To update your Python Shinylive package, run:\\n\",\n      \"\\tpip install --upgrade shinylive\\n\",\n      \"(If you are using a virtual environment, please activate it before running the command above.)\\n\",\n      \"\\n\"\n    )\n  end\n\n  -- Add language-specific dependencies\n  local langResources = callShinylive(language, { \"extension\", \"language-resources\" })\n  for idx, resourceDep in ipairs(langResources) do\n    -- No need to check for uniqueness.\n    -- Each resource is only be added once and should already be unique.\n    quarto.doc.attach_to_dependency(\"shinylive\", resourceDep)\n  end\nend\n\nfunction getShinyliveBaseDeps(language)\n  -- Relative path from the current page to the root of the site. This is needed\n  -- to find out where shinylive-sw.js is, relative to the current page.\n  if quarto.project.offset == nil then\n    throw_quarto_error(\"The `shinylive` extension must be used in a Quarto project directory (with a _quarto.yml file).\")\n  end\n  local deps = callShinylive(\n    language,\n    { \"extension\", \"base-htmldeps\", \"--sw-dir\", quarto.project.offset },\n    \"\"\n  )\n  return deps\nend\n\nreturn {\n  {\n    CodeBlock = function(el)\n      if not el.attr then\n        -- Not a shinylive codeblock, return\n        return\n      end\n\n      local language\n      if el.attr.classes:includes(\"{shinylive-r}\") then\n        language = \"r\"\n      elseif el.attr.classes:includes(\"{shinylive-python}\") then\n        language = \"python\"\n      else\n        -- Not a shinylive codeblock, return\n        return\n      end\n      -- Setup language and language-agnostic dependencies\n      ensureLanguageSetup(language)\n\n      -- Convert code block to JSON string in the same format as app.json.\n      local parsedCodeblockJson = pandoc.pipe(\n        \"quarto\",\n        { \"run\", codeblockScript, language },\n        el.text\n      )\n\n      -- This contains \"files\" and \"quartoArgs\" keys.\n      local parsedCodeblock = quarto.json.decode(parsedCodeblockJson)\n\n      -- Find Python package dependencies for the current app.\n      local appDeps = callShinylive(\n        language,\n        { \"extension\", \"app-resources\" },\n        -- Send as piped input to the shinylive command\n        quarto.json.encode(parsedCodeblock[\"files\"])\n      )\n\n      -- Add app specific dependencies\n      for idx, dep in ipairs(appDeps) do\n        if not appSpecificDeps[dep.name] then\n          appSpecificDeps[dep.name] = true\n          quarto.doc.attach_to_dependency(\"shinylive\", dep)\n        end\n      end\n\n      if el.attr.classes:includes(\"{shinylive-python}\") then\n        el.attributes.engine = \"python\"\n        el.attr.classes = pandoc.List()\n        el.attr.classes:insert(\"shinylive-python\")\n      elseif el.attr.classes:includes(\"{shinylive-r}\") then\n        el.attributes.engine = \"r\"\n        el.attr.classes = pandoc.List()\n        el.attr.classes:insert(\"shinylive-r\")\n      end\n      return el\n    end\n  }\n}\n","type":"text"},{"name":"shinylive_testing.Rproj","content":"Version: 1.0\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: pdfLaTeX\n","type":"text"}]
